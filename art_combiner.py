#!/usr/bin/env python3
"""
Abstract Art Combiner

This program combines multiple PNG images generated by abstract_art_generator.py
into a single composite image using various layout and blending techniques.
"""

import argparse
import os
import sys
from PIL import Image, ImageDraw, ImageFilter, ImageEnhance
import math
import random
from typing import List, Tuple, Optional

class ArtCombiner:
    def __init__(self):
        self.blend_modes = [
            'normal', 'multiply', 'screen', 'overlay', 'soft_light', 
            'hard_light', 'color_dodge', 'color_burn'
        ]
    
    def load_images(self, image_paths: List[str]) -> List[Image.Image]:
        """Load and validate input images"""
        images = []
        for path in image_paths:
            if not os.path.exists(path):
                print(f"Warning: File not found: {path}")
                continue
            
            try:
                img = Image.open(path)
                if img.mode != 'RGB':
                    img = img.convert('RGB')
                images.append(img)
                print(f"Loaded: {path} ({img.size[0]}x{img.size[1]})")
            except Exception as e:
                print(f"Error loading {path}: {e}")
        
        if not images:
            raise ValueError("No valid images could be loaded")
        
        return images
    
    def resize_images_to_match(self, images: List[Image.Image], 
                              target_size: Optional[Tuple[int, int]] = None) -> List[Image.Image]:
        """Resize all images to the same dimensions"""
        if target_size is None:
            # Use the size of the largest image
            max_width = max(img.size[0] for img in images)
            max_height = max(img.size[1] for img in images)
            target_size = (max_width, max_height)
        
        resized_images = []
        for img in images:
            if img.size != target_size:
                resized = img.resize(target_size, Image.Resampling.LANCZOS)
                resized_images.append(resized)
            else:
                resized_images.append(img)
        
        print(f"Resized all images to: {target_size[0]}x{target_size[1]}")
        return resized_images
    
    def create_grid_layout(self, images: List[Image.Image], 
                          cols: Optional[int] = None, 
                          spacing: int = 10,
                          background_color: Tuple[int, int, int] = (255, 255, 255)) -> Image.Image:
        """Arrange images in a grid layout"""
        num_images = len(images)
        
        if cols is None:
            cols = math.ceil(math.sqrt(num_images))
        
        rows = math.ceil(num_images / cols)
        
        # Get dimensions of individual images
        img_width, img_height = images[0].size
        
        # Calculate total canvas size
        canvas_width = cols * img_width + (cols - 1) * spacing
        canvas_height = rows * img_height + (rows - 1) * spacing
        
        # Create canvas
        canvas = Image.new('RGB', (canvas_width, canvas_height), background_color)
        
        # Place images
        for i, img in enumerate(images):
            row = i // cols
            col = i % cols
            
            x = col * (img_width + spacing)
            y = row * (img_height + spacing)
            
            canvas.paste(img, (x, y))
        
        print(f"Created grid layout: {cols}x{rows} ({canvas_width}x{canvas_height})")
        return canvas
    
    def create_layered_composite(self, images: List[Image.Image], 
                               blend_mode: str = 'normal',
                               opacity_range: Tuple[float, float] = (0.3, 0.8)) -> Image.Image:
        """Layer images on top of each other with blending"""
        if not images:
            raise ValueError("No images provided")
        
        # Start with the first image as base
        result = images[0].copy()
        
        for i, img in enumerate(images[1:], 1):
            # Create overlay with random opacity
            opacity = random.uniform(opacity_range[0], opacity_range[1])
            overlay = img.copy()
            
            # Apply opacity
            if blend_mode == 'normal':
                # Simple alpha blending
                overlay = overlay.convert('RGBA')
                alpha = int(255 * opacity)
                overlay.putalpha(alpha)
                
                result = result.convert('RGBA')
                result = Image.alpha_composite(result, overlay)
                result = result.convert('RGB')
            
            elif blend_mode == 'multiply':
                result = self._blend_multiply(result, overlay, opacity)
            elif blend_mode == 'screen':
                result = self._blend_screen(result, overlay, opacity)
            elif blend_mode == 'overlay':
                result = self._blend_overlay(result, overlay, opacity)
            else:
                # Default to normal blending
                result = self._blend_normal(result, overlay, opacity)
        
        print(f"Created layered composite with {len(images)} layers using {blend_mode} blend mode")
        return result
    
    def create_split_composition(self, images: List[Image.Image], 
                               split_type: str = 'horizontal') -> Image.Image:
        """Create compositions by splitting and combining parts of images"""
        if len(images) < 2:
            raise ValueError("Need at least 2 images for split composition")
        
        # Ensure all images are the same size
        images = self.resize_images_to_match(images)
        width, height = images[0].size
        
        result = Image.new('RGB', (width, height))
        
        if split_type == 'horizontal':
            # Split horizontally and combine
            strip_height = height // len(images)
            for i, img in enumerate(images):
                y_start = i * strip_height
                y_end = min((i + 1) * strip_height, height)
                
                strip = img.crop((0, y_start, width, y_end))
                result.paste(strip, (0, y_start))
        
        elif split_type == 'vertical':
            # Split vertically and combine
            strip_width = width // len(images)
            for i, img in enumerate(images):
                x_start = i * strip_width
                x_end = min((i + 1) * strip_width, width)
                
                strip = img.crop((x_start, 0, x_end, height))
                result.paste(strip, (x_start, 0))
        
        elif split_type == 'diagonal':
            # Create diagonal splits
            result = self._create_diagonal_split(images)
        
        elif split_type == 'radial':
            # Create radial/circular splits
            result = self._create_radial_split(images)
        
        print(f"Created {split_type} split composition")
        return result
    
    def create_mosaic(self, images: List[Image.Image], 
                     tile_size: int = 100,
                     randomize: bool = True) -> Image.Image:
        """Create a mosaic using pieces from different images"""
        if not images:
            raise ValueError("No images provided")
        
        # Use the first image's dimensions as reference
        base_width, base_height = images[0].size
        
        # Create result canvas
        result = Image.new('RGB', (base_width, base_height))
        
        # Calculate number of tiles
        tiles_x = base_width // tile_size
        tiles_y = base_height // tile_size
        
        for y in range(tiles_y):
            for x in range(tiles_x):
                # Choose random source image
                source_img = random.choice(images) if randomize else images[x % len(images)]
                
                # Calculate tile coordinates
                tile_x = x * tile_size
                tile_y = y * tile_size
                
                # Extract tile from source
                tile = source_img.crop((tile_x, tile_y, 
                                      min(tile_x + tile_size, source_img.size[0]),
                                      min(tile_y + tile_size, source_img.size[1])))
                
                # Paste tile to result
                result.paste(tile, (tile_x, tile_y))
        
        print(f"Created mosaic with {tile_size}x{tile_size} tiles ({tiles_x}x{tiles_y} grid)")
        return result
    
    def _blend_normal(self, base: Image.Image, overlay: Image.Image, opacity: float) -> Image.Image:
        """Normal blend mode with opacity"""
        overlay_rgba = overlay.convert('RGBA')
        alpha = int(255 * opacity)
        overlay_rgba.putalpha(alpha)
        
        base_rgba = base.convert('RGBA')
        result = Image.alpha_composite(base_rgba, overlay_rgba)
        return result.convert('RGB')
    
    def _blend_multiply(self, base: Image.Image, overlay: Image.Image, opacity: float) -> Image.Image:
        """Multiply blend mode"""
        import numpy as np
        
        base_array = np.array(base, dtype=np.float32) / 255.0
        overlay_array = np.array(overlay, dtype=np.float32) / 255.0
        
        # Multiply blend
        result_array = base_array * overlay_array
        
        # Apply opacity
        result_array = base_array * (1 - opacity) + result_array * opacity
        
        # Convert back to image
        result_array = np.clip(result_array * 255, 0, 255).astype(np.uint8)
        return Image.fromarray(result_array)
    
    def _blend_screen(self, base: Image.Image, overlay: Image.Image, opacity: float) -> Image.Image:
        """Screen blend mode"""
        import numpy as np
        
        base_array = np.array(base, dtype=np.float32) / 255.0
        overlay_array = np.array(overlay, dtype=np.float32) / 255.0
        
        # Screen blend: 1 - (1-base) * (1-overlay)
        result_array = 1 - (1 - base_array) * (1 - overlay_array)
        
        # Apply opacity
        result_array = base_array * (1 - opacity) + result_array * opacity
        
        # Convert back to image
        result_array = np.clip(result_array * 255, 0, 255).astype(np.uint8)
        return Image.fromarray(result_array)
    
    def _blend_overlay(self, base: Image.Image, overlay: Image.Image, opacity: float) -> Image.Image:
        """Overlay blend mode"""
        import numpy as np
        
        base_array = np.array(base, dtype=np.float32) / 255.0
        overlay_array = np.array(overlay, dtype=np.float32) / 255.0
        
        # Overlay blend
        result_array = np.where(
            base_array < 0.5,
            2 * base_array * overlay_array,
            1 - 2 * (1 - base_array) * (1 - overlay_array)
        )
        
        # Apply opacity
        result_array = base_array * (1 - opacity) + result_array * opacity
        
        # Convert back to image
        result_array = np.clip(result_array * 255, 0, 255).astype(np.uint8)
        return Image.fromarray(result_array)
    
    def _create_diagonal_split(self, images: List[Image.Image]) -> Image.Image:
        """Create diagonal split composition"""
        width, height = images[0].size
        result = Image.new('RGB', (width, height))
        
        # Create diagonal mask
        mask = Image.new('L', (width, height), 0)
        draw = ImageDraw.Draw(mask)
        
        # Divide diagonally based on number of images
        for i, img in enumerate(images):
            if i == 0:
                # First image takes upper triangle
                draw.polygon([(0, 0), (width, 0), (0, height)], fill=255)
                result.paste(img, mask=mask)
                mask = Image.new('L', (width, height), 0)
                draw = ImageDraw.Draw(mask)
            elif i == 1:
                # Second image takes lower triangle
                draw.polygon([(width, 0), (width, height), (0, height)], fill=255)
                result.paste(img, mask=mask)
            # For more images, create more complex diagonal patterns
        
        return result
    
    def _create_radial_split(self, images: List[Image.Image]) -> Image.Image:
        """Create radial/circular split composition"""
        width, height = images[0].size
        result = Image.new('RGB', (width, height))
        
        center_x, center_y = width // 2, height // 2
        
        # Create radial segments
        angle_per_image = 360 / len(images)
        
        for i, img in enumerate(images):
            mask = Image.new('L', (width, height), 0)
            draw = ImageDraw.Draw(mask)
            
            start_angle = i * angle_per_image
            end_angle = (i + 1) * angle_per_image
            
            # Create pie slice
            draw.pieslice([0, 0, width, height], start_angle, end_angle, fill=255)
            
            # Apply mask and paste
            temp = Image.new('RGB', (width, height))
            temp.paste(img, mask=mask)
            result = Image.alpha_composite(result.convert('RGBA'), temp.convert('RGBA')).convert('RGB')
        
        return result

def main():
    parser = argparse.ArgumentParser(
        description="Combine multiple abstract art images into a single composition",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Composition Types:
  grid        - Arrange images in a grid layout
  layered     - Layer images with blending modes
  split       - Split and recombine parts of images
  mosaic      - Create mosaic using tiles from different images

Examples:
  python art_combiner.py --input *.png --output combined.png --type grid
  python art_combiner.py --input art1.png art2.png --type layered --blend multiply
  python art_combiner.py --input *.png --type split --split-mode horizontal
  python art_combiner.py --input *.png --type mosaic --tile-size 50
        """
    )
    
    parser.add_argument(
        '--input', '-i',
        nargs='+',
        required=True,
        help='Input PNG files (supports wildcards)'
    )
    
    parser.add_argument(
        '--output', '-o',
        default='combined_artwork.png',
        help='Output filename (default: combined_artwork.png)'
    )
    
    parser.add_argument(
        '--type', '-t',
        choices=['grid', 'layered', 'split', 'mosaic'],
        default='grid',
        help='Composition type (default: grid)'
    )
    
    parser.add_argument(
        '--cols',
        type=int,
        help='Number of columns for grid layout (auto-calculated if not specified)'
    )
    
    parser.add_argument(
        '--spacing',
        type=int,
        default=10,
        help='Spacing between images in grid layout (default: 10)'
    )
    
    parser.add_argument(
        '--blend',
        choices=['normal', 'multiply', 'screen', 'overlay'],
        default='normal',
        help='Blend mode for layered composition (default: normal)'
    )
    
    parser.add_argument(
        '--opacity-min',
        type=float,
        default=0.3,
        help='Minimum opacity for layered composition (default: 0.3)'
    )
    
    parser.add_argument(
        '--opacity-max',
        type=float,
        default=0.8,
        help='Maximum opacity for layered composition (default: 0.8)'
    )
    
    parser.add_argument(
        '--split-mode',
        choices=['horizontal', 'vertical', 'diagonal', 'radial'],
        default='horizontal',
        help='Split mode for split composition (default: horizontal)'
    )
    
    parser.add_argument(
        '--tile-size',
        type=int,
        default=100,
        help='Tile size for mosaic composition (default: 100)'
    )
    
    parser.add_argument(
        '--width',
        type=int,
        help='Target width for resizing all images (optional)'
    )
    
    parser.add_argument(
        '--height',
        type=int,
        help='Target height for resizing all images (optional)'
    )
    
    parser.add_argument(
        '--seed',
        type=int,
        help='Random seed for reproducible results (optional)'
    )
    
    args = parser.parse_args()
    
    # Set random seed if provided
    if args.seed is not None:
        random.seed(args.seed)
        print(f"Using random seed: {args.seed}")
    
    print("Abstract Art Combiner")
    print("=" * 30)
    print(f"Composition type: {args.type}")
    print(f"Output: {args.output}")
    
    try:
        # Initialize combiner
        combiner = ArtCombiner()
        
        # Load images
        print(f"\nLoading {len(args.input)} input files...")
        images = combiner.load_images(args.input)
        
        if not images:
            print("Error: No valid images found!")
            return 1
        
        print(f"Successfully loaded {len(images)} images")
        
        # Resize images if target dimensions specified
        if args.width and args.height:
            target_size = (args.width, args.height)
            images = combiner.resize_images_to_match(images, target_size)
        
        # Create composition based on type
        if args.type == 'grid':
            result = combiner.create_grid_layout(
                images, 
                cols=args.cols, 
                spacing=args.spacing
            )
        
        elif args.type == 'layered':
            # Resize to match for layered composition
            images = combiner.resize_images_to_match(images)
            result = combiner.create_layered_composite(
                images,
                blend_mode=args.blend,
                opacity_range=(args.opacity_min, args.opacity_max)
            )
        
        elif args.type == 'split':
            result = combiner.create_split_composition(
                images,
                split_type=args.split_mode
            )
        
        elif args.type == 'mosaic':
            # Resize to match for mosaic
            images = combiner.resize_images_to_match(images)
            result = combiner.create_mosaic(
                images,
                tile_size=args.tile_size,
                randomize=True
            )
        
        # Save result
        result.save(args.output, 'PNG', quality=95)
        print(f"\nCombined artwork saved as: {args.output}")
        
        # Display file info
        file_size = os.path.getsize(args.output)
        print(f"File size: {file_size:,} bytes ({file_size/1024:.1f} KB)")
        print(f"Dimensions: {result.size[0]}x{result.size[1]}")
        print("\nCombination complete!")
        
        return 0
        
    except Exception as e:
        print(f"Error: {e}")
        return 1

if __name__ == "__main__":
    # Check for required packages
    try:
        from PIL import Image, ImageDraw, ImageFilter, ImageEnhance
        import numpy as np
    except ImportError as e:
        print(f"Missing required package: {e}")
        print("Install with: pip install pillow numpy")
        sys.exit(1)
    
    sys.exit(main())
